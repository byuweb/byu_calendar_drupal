<?php
/**
 * @file
 * Updates the internal category list for BYU from an updated database of colleges and departments.
 */

/**
 * Implements hook_help().
 *
 * Displays help and module information.
 *
 * @param path
 *   Which path of the site we're using to display help
 * @param arg
 *   Array that holds the current path as returned from arg() function
 */
function calendar_widget_help($path, $arg) {

//  if($path == 'admin/structure') {
//    return t('This site has stuff');
//  }
}

function calendar_widget_menu() {
  $items['admin/config/date/calendar-widget'] = array(
      'title' => 'Calendar Widget',
      'description' => 'Set up calendar widget blocks to display events pulled from calendar.byu.edu.',
//      'page callback' => 'calendar_widget_overview_page',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('calendar_widget_form'),
      'access callback' => TRUE,

  );
  return $items;
}



function calendar_widget_form($form, &$form_state) {




  $form['info'] = array(
      '#type' => 'fieldset',
      '#title' => t('Cron status information'),
  );
  $form['info']['intro'] = array(
      '#markup' => '<div>' . t('The cron example demonstrates hook_cron() and hook_cron_queue_info() processing. If you have administrative privileges you can run cron from this page and see the results.') . '</div>',
  );
  $form['info']['last'] = array(
      '#markup' => '<div>' . t('calendar_widget_cron() will next execute the first time cron runs after %time (%seconds seconds from now)',
              array(
                  '%time' => date_iso8601(variable_get('calendar_widget_next_execution', time())),
                  '%seconds' => variable_get('calendar_widget_next_execution', time()) - time(),
              )
          ) . '</div>',
  );

  $form['calendar_widget_block_1'] = array(
      '#type' => 'fieldset',
      '#title' => t('Configuring Calendar Widget Block 1'),
  );
  $form['calendar_widget_block_1']['calendar_widget_dates'] = array(
      '#type' => 'select',
      '#title' => t('Included Dates'),
      '#description' => t('Time after which calendar_widget_cron will check for updates on the next cron run.'),
      '#default_value' => variable_get('calendar_widget_dates', 7),
      '#options' => array(
          1 => t('1 day (today only)'),
          7 => t('7 days'),
          10 => t('10 days'),
          14 => t('14 days'),
          30 => t('30 days'),
      ),
  );


  if (user_access('administer site configuration')) {
    $form['cron_run'] = array(
        '#type' => 'fieldset',
        '#title' => t('Run cron manually'),
    );
    $form['cron_run']['cron_reset'] = array(
        '#type' => 'checkbox',
        '#title' => t("Run calendar_widget's cron regardless of whether interval has expired."),
        '#default_value' => FALSE,
    );
    $form['cron_run']['cron_trigger'] = array(
        '#type' => 'submit',
        '#value' => t('Run cron now'),
        '#submit' => array('calendar_widget_form_cron_run_submit'),
    );
  }

  $form['cron_queue_setup'] = array(
      '#type' => 'fieldset',
      '#title' => t('Cron queue setup (for hook_cron_queue_info(), etc.)'),
  );
  $queue_1 = DrupalQueue::get('calendar_widget_queue_1');
  $queue_2 = DrupalQueue::get('calendar_widget_queue_2');
  $form['cron_queue_setup']['current_cron_queue_status'] = array(
      '#markup' => '<div>' . t('There are currently %queue_1 items in queue 1 and %queue_2 items in queue 2',
              array(
                  '%queue_1' => $queue_1->numberOfItems(),
                  '%queue_2' => $queue_2->numberOfItems(),
              )) . '</div>',
  );
  $form['cron_queue_setup']['num_items'] = array(
      '#type' => 'select',
      '#title' => t('Number of items to add to queue'),
      '#options' => drupal_map_assoc(array(1, 5, 10, 100, 1000)),
      '#default_value' => 5,
  );
  $form['cron_queue_setup']['queue'] = array(
      '#type' => 'radios',
      '#title' => t('Queue to add items to'),
      '#options' => array(
          'calendar_widget_queue_1' => t('Queue 1'),
          'calendar_widget_queue_2' => t('Queue 2'),
      ),
      '#default_value' => 'calendar_widget_queue_1',
  );
  $form['cron_queue_setup']['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Add jobs to queue'),
      '#submit' => array('calendar_widget_add_jobs_to_queue'),
  );



  $form['configuration'] = array(
      '#type' => 'fieldset',
      '#title' => t('Configuring Calendar Widget Update Frequency'),
  );
  $form['configuration']['calendar_widget_interval'] = array(
      '#type' => 'select',
      '#title' => t('Update interval'),
      '#description' => t('Time after which calendar_widget_cron will check for updates on the next cron run.'),
      '#default_value' => variable_get('calendar_widget_interval', 60 * 60),
      '#options' => array(
          60 => t('1 minute'),
          300 => t('5 minutes'),
          3600 => t('1 hour'),
          60 * 60 * 24 => t('1 day'),
      ),
  );

  return system_settings_form($form);

}


/**
 * Implements hook_cron().
 *
 * hook_cron() is the traditional (pre-Drupal 7) hook for doing "background"
 * processing. It gets called every time the Drupal cron runs  and must decide
 * what it will do.
 *
 * In this example, it does a watchdog() call after the time named in
 * the variable 'calendar_widget_next_execution' has arrived, and then it
 * resets that variable to a time in the future.
 */

// Giant function of everything to do when cron runs...
function calendar_widget_cron() {
  // Default to an hourly interval. Of course, cron has to be running at least
  // hourly for this to work.
  $interval = variable_get('calendar_widget_interval', 60 * 60);
  // If it has been the set amount of time to wait, then we will continue
  if (time() >= variable_get('calendar_widget_next_execution', 0)) {

  // what do to on cron run

    watchdog('calendar_widget', 'calendar_widget ran');
    if (!empty($GLOBALS['calendar_widget_show_status_message'])) {
      drupal_set_message(t('BYU Departments were updated at %time', array('%time' => date_iso8601(time(0)))));
    }
    variable_set('calendar_widget_next_execution', time() + $interval);
  } // end if statement of if it's waited long enough since last run

}

/* ------------------- cron example fxns -------- */


/**
 * Allow user to directly execute cron, optionally forcing it.
 */
function calendar_widget_form_cron_run_submit($form, &$form_state) {
  if (!empty($form_state['values']['cron_reset'])) {
    variable_set('calendar_widget_next_execution', 0);
  }

  // We don't usually use globals in this way. This is used here only to
  // make it easy to tell if cron was run by this form.
  $GLOBALS['calendar_widget_show_status_message'] = TRUE;
  if (drupal_cron_run()) {
    drupal_set_message(t('Cron ran successfully.'));
  }
  else {
    drupal_set_message(t('Cron run failed.'), 'error');
  }
}

/**
 * Submit function used to add the items to the queue.
 */
function calendar_widget_add_jobs_to_queue($form, &$form_state) {
  $queue = $form_state['values']['queue'];
  $num_items = $form_state['values']['num_items'];

  $queue = DrupalQueue::get($queue);
  for ($i = 1; $i <= $num_items; $i++) {
    $item = new stdClass();
    $item->created = time();
    $item->sequence = $i;
    $queue->createItem($item);
  }

}

/**
 * Implements hook_cron_queue_info().
 *
 * hook_cron_queue_info() and family are new since Drupal 7, and allow any
 * process to add work to the queue to be acted on when cron runs. Queues are
 * described and worker callbacks are provided, and then only the worker
 * callback needs to be implemented.
 *
 * All the details of queue use are done by the cron_queue implementation, so
 * one doesn't need to know much about DrupalQueue().
 *
 * @see queue_example.module
 */
function calendar_widget_cron_queue_info() {
  $queues['calendar_widget_queue_1'] = array(
      'worker callback' => 'calendar_widget_queue_1_worker',
    // One second max runtime per cron run.
      'time' => 1,
  );
  $queues['calendar_widget_queue_2'] = array(
      'worker callback' => 'calendar_widget_queue_2_worker',
      'time' => 10,
  );
  return $queues;
}

/**
 * Simple worker for our queues.
 *
 * @param object $item
 *   Any object to be worked on.
 */
function calendar_widget_queue_1_worker($item) {
  calendar_widget_queue_report_work(1, $item);
}

/**
 * Simple worker for our queues.
 *
 * @param object $item
 *   Any object to be worked on.
 */
function calendar_widget_queue_2_worker($item) {
  calendar_widget_queue_report_work(2, $item);
}

/**
 * Simple reporter for the workers.
 *
 * @param int $worker
 *   Worker number.
 * @param object $item
 *   The $item which was stored in the cron queue.
 */
function calendar_widget_queue_report_work($worker, $item) {
  if (!empty($GLOBALS['calendar_widget_show_status_message'])) {
    drupal_set_message(
        t('Queue @worker worker processed item with sequence @sequence created at @time',
            array(
                '@worker' => $worker,
                '@sequence' => $item->sequence,
                '@time' => date_iso8601($item->created),
            )
        )
    );
  }
  watchdog('calendar_widget', 'Queue @worker worker processed item with sequence @sequence created at @time',
      array(
          '@worker' => $worker,
          '@sequence' => $item->sequence,
          '@time' => date_iso8601($item->created),
      )
  );
}

/**
 * @} End of "defgroup calendar_widget".
 */


/**
 * Implements hook_block_info().
 * Define all the blocks for this module.
 * You can use a given hook exactly once in any module, so this hook must declare all blocks the module needs.
 */
function calendar_widget_block_info() {
  $blocks['calendar_widget_block_1'] = array(
    // The name that will appear in the block list.
      'info' => t('Calendar Widget Block 1'),
    // Default setting.
      'cache' => DRUPAL_CACHE_PER_ROLE,
  );
  $blocks['calendar_widget_block_2'] = array(
    // The name that will appear in the block list.
      'info' => t('Calendar Widget Block 2'),
    // Default setting.
      'cache' => DRUPAL_CACHE_PER_ROLE,
  );
  return $blocks;
}

/* -- custom fxn to fetch calendar events and return data for a block -- */
function calendar_widget_fetch_events(){
  // pull how many days forward to go
  $days = variable_get('calendar_widget_dates', 7);
  // today's time
  $startTime = time();
  //Get today's date
  $startDateOb = date_create("@$startTime");
  $startDate = date_format($startDateOb, 'Y-m-d');

  //Calculate the date a week ago.
  //$end_time = mktime(0, 0, 0, $today['mon'], ($today['mday'] + $days), $today['year']);
  $endTime = $startTime + ($days * 24 * 3600);
  $endDateOb = date_create_from_format('U', $endTime);
  $endDate = date_format($endDateOb, 'Y-m-d');

  // convert to Y-m-d format

  // placeholder
  $eventsData = '<h3>' . $startDate . ' through ' . $endDate . '</h3><p>HEre is some text.</p><p>And here is some more text.</p>';

  return $eventsData;
}
/* test function to fetch events posted recently -- */
function calendar_widget_contents() {
  //Get today's date
  $today = getdate();
  //Calculate the date a week ago.
  $start_time = mktime(0, 0, 0, $today['mon'], ($today['mday'] - 7), $today['year']);
  //Get all posts from one week ago to the present.
  $end_time = time();

  //Use Database API to retrieve current posts.
  $recentNodes = db_select('node', 'n')
      ->fields('n', array('nid', 'title', 'created'))
      ->condition('status', 1) //Published.
      ->condition('created', array($start_time, $end_time), 'BETWEEN')
      ->orderBy('created', 'DESC') //Most recent first.
      ->execute();
  return $recentNodes;

}


/*
*
 *
*/

function calendar_widget_block_view($delta = '') {
  switch ($delta) {
    case 'calendar_widget_block_1':
      $block['subject'] = t('Calendar Widget Text');
      if (user_access('access content')) {
        // Retrieve and process data here.
        // Use our custom function to retrieve data.
//        $result = calendar_widget_contents();
        $result = calendar_widget_fetch_events();
        // Array to contain items for the block to render.
        $items = array();
        // Iterate over the result set and format as links.
        foreach ($result as $node) {
          $items[] = array(
              'data' => l($node->title, 'node/' . $node->nid),
          );
        }
//        $block['content'] = t('There are probably events.');

        // return back to the block
        // No data returned for the block / no events.
          if (empty($result)) {
            $block['content'] = t('No events.');
          }
          else {
            //Pass data through theme function.
            $block['content'] = t($result);

            //$block['content'] = theme('item_list', array(
//                'items' => $items));
//            $block['content'] = t('There are events.');
            // calendar_widget_fetch_events(){
          }
        }
        return $block;
  }

}